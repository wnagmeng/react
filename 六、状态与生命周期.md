---
marp: true
paginate: true
style: |
  h1 {
    color: #0bb8e8;
    text-align: center;
  }
---

# 状态与生命周期

---

# 状态：可修改的内容

由于React中组件的属性是不可修改的。
所以我们需要引入一个新的东西，表现可变化的内容。
这个东西就是状态(state)。
状态(state)与属性(props)类似。
但是状态是组件私有，完全控制的。
而属性(props)不允许被修改。

---
# 创建一个需要修改的组件

我们基于tick的例子进行创建：

1. 给它一个Clock的组件名
2. 把变化的部分变成是状态(state)

那么我们得到这样一个组件：

---

```
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
---
## 说明

1. props原封不动的被传递给父元素
2. 手动创建了一个包含date属性的state

---

# 让时间可以更新

这个时候我们已经有了一个date属性在state上了。
我们需要调用React组件的方法`setState`来实现状态的更新。所以下面的tick函数用于更新date这个属性。

```
  tick() {
    this.setState({
      date: new Date()
    });
  }
```

>注意： 必须通过setState变更this.state。
>以下代码是错误的，这样无法让组件界面更新：
```
  tick() {
    this.state.date = new Date();
  }
```



---

# 让时钟动起来

创建了基本的结构后，我们还要让时钟不断的更新。

也就是需要不断的让状态(state)更新

这里我们通过一个函数`componentDidMount`来实现：

```
  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }
```

函数componentDidMount是一个生命周期函数。表示在组件正式加载完成后会执行。

---

# 让timer随着组件的清除而清除
在这里我们创建了一个timer，如果这个组件被替换时，
他可能仍不断的被调用，从而影响调用。所以我们有必要让这个timer被回收回去。

这时我们需要调用另外一个生命周期函数`componentWillUnmount`，让这个组件在完全退出前先清理掉之前创建的timer.

```
  componentWillUnmount() {
    clearInterval(this.timerID);
  }
```

这样一个完善的时钟就完成了。完整代码(基于TS)如下：

---
```
import React from "react";

interface States {
  date: Date;
};

class Clock extends React.Component<{}, States> {
  private timer:NodeJS.Timeout;
  constructor(props:any) {
    super(props);
    this.state = { date: new Date() };
    this.timer = setInterval(() => {}, 1000);
  }

  componentDidMount() {
    clearInterval(this.timer);
    this.timer = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
---

# 正确的使用状态(state)

1. 状态不能直接修改状态的值
```
// Wrong
this.state.comment = 'Hello';
// Correct
this.setState({comment: 'Hello'});
```

---
# 正确的使用状态(state)

2. `setState`函数执行可能是异步的
所以避免使用this域，导致数据不一致。应该使用当前变量。
```
// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
// Correct
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

---
# 正确的使用状态(state)

3. 状态的更新是合并的
可以一起更新，也可以单独更新。

```
this.setState({
  a: 1,
  b: 2
});
```
和
```
this.setState({
  a: 1
});
this.setState({
  b: 1
});
```
等价








